/**
 * @file wunder.c
 * @author Dan Albert
 * @date Created 12/15/2010
 * @date Last updated 12/15/2010
 * @version 1.0
 *
 * @section LICENSE
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 * 
 * @section DESCRIPTION
 * 
 * This program will test the various components of the Wunderboard when used
 * with the corresponding host test script.
 * 
 */
#include <avr/delay.h>
#include <avr/interrupt.h>
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "adc.h"
#include "diskio.h"
#include "types.h"
#include "usart.h"

// 9600 baud
#define BAUD_RATE 51

#define CPU_PRESCALE(n) (CLKPR = 0x80, CLKPR = (n))

#define TEST_LED_OFF		'a'
#define TEST_LED_GREEN		'b'
#define TEST_LED_AMBER		'c'
#define TEST_LED_RED		'd'
#define TEST_MICROPHONE		'e'
#define TEST_ACCELEROMETER	'f'
#define TEST_MMC			'g'
#define TEST_SWITCHES_OFF	'h'
#define TEST_SWITCHES_ON	'i'

unsigned char row = 0;
unsigned char column = 0;

/*ISR(TIMER0_OVF)
  {
  column++;
  }*/

const unsigned char ascii [] = {
	0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x40, 0x00,
	0x00, 0x00, 0x40, 0x30, 0x08, 0x06, 0x01, 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x40, 0x42,
	0x7F, 0x40, 0x40, 0x00, 0x62, 0x51, 0x51, 0x51, 0x4E, 0x00, 0x22, 0x41, 0x49, 0x49, 0x3E, 0x00,
	0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x4F, 0x49, 0x49, 0x49, 0x31, 0x00, 0x3E, 0x49, 0x49, 0x49,
	0x32, 0x00, 0x01, 0x01, 0x71, 0x09, 0x07, 0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x26, 0x49,
	0x49, 0x49, 0x3E, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x80, 0x68, 0x00, 0x00, 0x00,
	0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x22, 0x14, 0x08,
	0x00, 0x02, 0x01, 0xB1, 0x09, 0x06, 0x00, 0x3E, 0x4D, 0x53, 0x55, 0x2E, 0x00, 0x78, 0x16, 0x11,
	0x16, 0x78, 0x00, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x7F,
	0x41, 0x41, 0x41, 0x3E, 0x00, 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x7F, 0x09, 0x09, 0x09, 0x01,
	0x00, 0x3E, 0x41, 0x41, 0x49, 0x3A, 0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x41, 0x41, 0x7F,
	0x41, 0x41, 0x00, 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x7F,
	0x40, 0x40, 0x40, 0x40, 0x00, 0x7F, 0x02, 0x04, 0x02, 0x7F, 0x00, 0x7F, 0x06, 0x08, 0x30, 0x7F,
	0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x3E, 0x41, 0x41,
	0x61, 0x5E, 0x00, 0x7F, 0x09, 0x09, 0x19, 0x66, 0x00, 0x26, 0x49, 0x49, 0x49, 0x32, 0x00, 0x01,
	0x01, 0x7F, 0x01, 0x01, 0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x07, 0x18, 0x60, 0x18, 0x07,
	0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x01, 0x02, 0x7C,
	0x02, 0x01, 0x00, 0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
}; /**<ASCII table used for displaying characters. \image html ascii.bmp*/

//LCD PORT DEFINATIONS
#define LCD_CS_n 4 /**<PORTB: PIN4 - Chip Select for LCD. OUTPUT. Active Low.*/
#define LCD_A0 6 /**<PORTD: PIN6 - Command/Data Select for LCD. OUTPUT.*/
#define LCD_RST_n 5 /**<PORTD: PIN5 - Reset for LCD. OUTPUT. Active Low.*/
#define LCD_BKLGHT 7 // LCD Back Light

#define x_size 8 /**<LCD height in rows.*/
#define y_size 128 /**<LCD width in pixels*/
uint8_t display [x_size][y_size] = { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff},
	{0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff, 0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff, 0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff},
	{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff},
	{0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff, 0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff, 0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff},
	{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff},
	{0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff, 0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff, 0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff},
	{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff},
	{0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff, 0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff, 0xff, 0xff, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xff, 0xff}};



void SPI_MasterTransmit(uint8_t cData)
{
	uint8_t temp;
	// Start transmission 
	PORTB &= ~(1<<LCD_CS_n);
	SPDR = cData;
	// Wait for transmission complete
	//temp = SPSR & (1<<SPIF);
	//while(temp);


	while((SPSR & (0x80)) == 0x00);

	temp=SPDR;
	PORTB |= 1<<LCD_CS_n;
}


void lcdinit()
{
	DDRD |= (1<<LCD_RST_n) | (1<<LCD_A0) | (1<<LCD_BKLGHT);//Setup DDRD
	DDRB |= (1<<LCD_CS_n);//Setup DDRB
	PORTD |= (1<<LCD_RST_n) | (1<<LCD_BKLGHT);
	PORTD &= ~((1<<LCD_A0));

	SPCR = 0b01010001;

	_delay_ms(20);

	SPI_MasterTransmit(0xA2);
	_delay_us(1);

	SPI_MasterTransmit(0xA1); //Was A0
	_delay_us(1);
	SPI_MasterTransmit(0xC8);
	_delay_us(1);
	SPI_MasterTransmit(0xA4);
	_delay_us(1);
	SPI_MasterTransmit(0x40);
	_delay_us(1);

	SPI_MasterTransmit(0x25);
	_delay_us(1);
	SPI_MasterTransmit(0x81);
	_delay_us(1);
	SPI_MasterTransmit(0x6F);//Was 10
	_delay_us(1);

	SPI_MasterTransmit(0x2F);
	_delay_us(1);
	SPI_MasterTransmit(0xAF);
	_delay_us(1);
	//SPI_MasterTransmit(0xC5);
	_delay_us(1);

	PORTB |= (1<<LCD_CS_n);

}

void lcd_update(uint8_t (*fb)[y_size])
{
	uint8_t i, j;

	for (i=0;i<8;i++)
	{
		PORTD &= ~(1<<LCD_A0); // Set A0 to Low (Default)
		SPI_MasterTransmit(0xB0 | i);
		SPI_MasterTransmit(0x10);
		SPI_MasterTransmit(0x00);
		PORTD |= 1<<LCD_A0; // Set A0 to High 
		for (j=128;j>0;j--)
			SPI_MasterTransmit(fb[i][j-1]);
	}
}


void fb_itoa(uint8_t input, uint8_t *sprite, uint8_t digits)
{
	uint8_t i = 0, j = 0, k = 0, temp = 0;

	k = 3-digits;

	for (i=0;i<digits;i++)
	{
		if ((i+k) == 0)
			temp = input/100;
		if ((i+k) == 1){
			temp = input%100;
			temp = temp/10;
		}
		if ((i+k) == 2)
			temp = input%10;
		for (j=0;j<6;j++)
			sprite[(i*6)+j] = ascii[(temp*6)+(6*4)+j];
	}	
}


void clearArray(void)
{
	PORTB &= ~((1 << PB6) | (1 << PB7));	// Disable latches
	PORTC = 0x00;
	PORTB |= (1 << PB6) | (1 << PB7);		// Enable latches
	PORTB &= ~((1 << PB6) | (1 << PB7));	// Disable latches
}

void setArrayGreen(unsigned char rows)
{
	clearArray();
	PORTC = rows;
	PORTB |= (1 << PB7);
	PORTB &= ~(1 << PB7);
}

void setArrayAmber(unsigned char rows)
{
	clearArray();
	PORTC = rows;
	PORTB |= (1 << PB7) | (1 << PB6);
	PORTB &= ~((1 << PB7) | (1 << PB6));;
}

void setArrayRed(unsigned char rows)
{
	clearArray();
	PORTC = rows;
	PORTB |= (1 << PB6);
	PORTB &= ~(1 << PB6);
}

int main(void)
{
	DSTATUS status;
	uint8_t buffer[512];
	unsigned char recv;
	unsigned char initialX;
	unsigned char initialY;
	unsigned char initialZ;
	unsigned char initialMic;
	BOOL xPassed = FALSE;
	BOOL yPassed = FALSE;
	BOOL zPassed = FALSE;

	CPU_PRESCALE(0);

	USART_Init(BAUD_RATE);
	USART_Transmit('\f');	// Send form feed to clear the terminal.
	USART_SendString("WunderBoard initializing...\r\n");

	USART_SendString("\tSetting ADC prescaler and disabling free running mode...\r\n");
	SetupADC(ADC_PRESCALER_32, FALSE);

	USART_SendString("\tEnabling ADC...\r\n");
	ADCEnable();

	USART_SendString("\tSetting ADC reference to Vcc...\r\n");
	ADCSetReference(ADC_REF_VCC);

	// Configure IO //
	USART_SendString("\tConfiguring IO...\r\n");
	DDRA = 0x00;	// Buttons and switches
	DDRB = 0xe7;	// Red enable, green enable and audio out
	DDRC = 0xff;	// Rows
	DDRE = 0x47;	// Columns and relay
	DDRF = 0x0f;	// Accelerometer and microphone

	// Disable pullups and set outputs low //
	PORTA = 0x00;
	PORTB = 0x00;
	PORTE = 0x00;
	PORTF = 0x00;

	clearArray();



	// Inserted Code
	lcdinit();
	fb_itoa(156,display,3);
	lcd_update(display);
	_delay_ms(500);


	//end of inserted code




	// Setup timer for LED array //
	/*TCCR1A = 0x00;
	  TCCR1B = (1 << CS10);
	  TIMSK1 = (1 << TOIE1);
	  sei();*/

	// PORTB = (1 << PB7);	// Green enable

	// Wait for data


	USART_SendString("Testing array off\r\n");
	clearArray();

	// Wait for signal to test LED array (green)
	USART_SendString("Waiting to Test Green Array Press 'b'\r\n");

	_delay_ms(100);
	USART_SendString("Testing array green\r\n");
	setArrayRed(0xff);
	// Wait for signal to test LED array (amber)
	USART_SendString("Waiting to Test Amber Array Press 'c'\r\n");


	_delay_ms(100);
	USART_SendString("Testing array amber\r\n");
	setArrayAmber(0xff);

	// Wait for signal to test LED array (red)
	USART_SendString("Waiting to Test Red Array Press 'd'\r\n");

	_delay_ms(100);
	USART_SendString("Testing array red\r\n");
	setArrayGreen(0xff);

	USART_SendString("Waiting to Test microphone Press 'e'\r\n");
	// Wait for signal to test microphone

	_delay_ms(100);
	USART_SendString("Testing microphone\r\n");

	char temp_str[8];

	initialMic = ReadADC(ADC_MUX_ADC4);
	initialMic = ReadADC(ADC_MUX_ADC4);

	while (1)
	{
		recv = ReadADC(ADC_MUX_ADC4);
		itoa(recv,temp_str,10);

		USART_SendString(temp_str);
		USART_SendString("\n");

		if ((recv) > (initialMic+40))
			break;

	}

	USART_Transmit(TRUE);

	// Wait for signal to test accelerometer
	USART_SendString("\nWaiting to Test Accelerometers Press 'f'\r\n");

	// Removed because the test will pass on the host once data is available
	//USART_SendString("Testing accelerometer\r\n");

	initialX = ReadADC(ADC_MUX_ADC5);
	initialY = ReadADC(ADC_MUX_ADC6);
	initialZ = ReadADC(ADC_MUX_ADC7);

	while ((!xPassed) || (!yPassed) || (!zPassed))
	{
		unsigned char x;
		unsigned char y;
		unsigned char z;

		x = ReadADC(ADC_MUX_ADC5);
		y = ReadADC(ADC_MUX_ADC6);
		z = ReadADC(ADC_MUX_ADC7);
		USART_Transmit(x);
		USART_Transmit(',');
		USART_Transmit(y);
		USART_Transmit(',');
		USART_Transmit(z);
		USART_Transmit('\n');

		if (abs(x - initialX) > 20)
		{
			xPassed = TRUE;
		}

		if (abs(y - initialY) > 20)
		{
			yPassed = TRUE;
		}
		//zPassed = TRUE;
		if (abs(z - initialZ) > 20)
		{
			zPassed = TRUE;
		}
	}

	USART_Transmit(TRUE);

	// Wait for signal to test MMC/SDC
	USART_SendString("\nWaiting to Test SD/MMC Press 'g'\r\n");
	recv = 0;
	while (recv != TEST_MMC)
	{
		while (!USART_Available())
		{
		}

		recv = USART_Receive();
	}

	_delay_ms(100);
	status = disk_initialize(0);

	if (status & STA_NOINIT)
	{
		setArrayGreen(0x01);
		USART_SendString("The MMC/SDC failed to initialize.\r\n");
		while (1);
		USART_Transmit(FALSE);
	}
	else
	{
		// Wait for data
		USART_SendString("Enter characters to write!\r\n");
		while (!USART_Available())
		{
		}

		memset(buffer, 0, 512 * sizeof(uint8_t));
		*buffer = USART_Receive();

		if (disk_write(0, buffer, 0, 1) == RES_ERROR)
		{
			setArrayGreen(0x02);
			USART_SendString("There was an error writing to LBA 0!\r\n");
			USART_Transmit(FALSE);
		}
		else{

			memset(buffer, 0, 512 * sizeof(uint8_t));
			if (disk_read(0, buffer, 0, 1) == RES_ERROR)
			{
				setArrayGreen(0x04);
				USART_SendString("There was an error reading from LBA 0!\r\n");
			}
			else{
				USART_Transmit(~buffer[0]);	// Transmit checksum
			}
		}
	}

	// Wait for signal to test buttons and switches off
	USART_SendString("Waiting to Test Buttons and Switches Press 'h'\r\n");

	_delay_ms(100);
	USART_SendString("Testing buttons and switches. Set all to Low Simultaneously\r\n");
	PORTB = 0b10000000;
	while (PINA != 0x00)
	{
		setArrayGreen(PINA);
	}

	USART_Transmit(TRUE);

	// Wait for signal to test buttons and switches on
	USART_SendString("Waiting to Test Buttons and Switches Press 'i'\r\n");

	_delay_ms(100);
	USART_SendString("Testing buttons and switches. Set all to High Simultaneously\r\n");
	PORTB = 0b01000000;
	while (PINA != 0xFF)
	{
		setArrayRed(PINA);
	}

	USART_Transmit(TRUE);

	USART_SendString("All tests Completed\r\n");
	setArrayAmber(0xff);
	while(1){
		PORTE = 0x00;
		PORTE = 0x01;
		PORTE = 0x02;
		PORTE = 0x03;
		PORTE = 0x04;
		PORTE = 0x05;
		PORTE = 0x06;
		PORTE = 0x07;
	}
}
